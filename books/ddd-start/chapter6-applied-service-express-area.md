6장. 응용 서비스와 표현 영역
===========

### 표현 영역과 응용 영역

![6.1.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/cdb86d89-eec4-464e-a0d4-096d4ca312d5/6.1.png)

- 표현 영역은 사용자의 요청을 해석한다.
- 실제 사용자가 원하는 기능을 제공하는 것은 응용 영역에 위치한 서비스이다.
- 응용 서비스의 메서드가 요구하는 파라미터와 표현 영역이 사용자로부터 전달받은 데이터는 형식이 일치하지 않기 때문에 표현 영역은 응용 서비스가 요구하는 형식으로 사용자 요청을 변환한다.
- 응용 서비스를 실행한 뒤에 표현 영역은 실행 결과를 사용자에 알맞은 형식으로 응답한다.
- 사용자와의 상호작용은 표현 영역이 처리하기 때문에 응용 서비스는 표현 영역에 의존하지 않는다.
- 단지, 응용 영역은 기능 실행에 필요한 입력값을 전달받고 실행 결과만 리턴하면 될 뿐이다.

### 응용 서비스의 역할

- 응용 서비스는 사용자(클라이언트)가 요청한 기능을 실행한다.
- 응용 서비스의 주요 역할은 도메인 객체를 사용해서 사용자의 요청을 처리하는 것이므로 표현(사용자) 영역 입장에서 보았을 때 응용 서비스는 도메인 영역과 표현 영역을 연결해 주는 창구인 파사드(facade) 역할을 한다.
- 도메인 객체 간의 실행 흐름을 제어하는 것과 더불어 응용 서비스의 주된 역할 중 하나는 트랜잭션 처리이다.

**도메인 로직 넣지 않기**

- 도메인 로직은 도메인 영역에 위치하고 응용 서비스는 도메인 로직을 구현하지 않는다고 했다.
- 도메인 로직을 도메인 영역과 응용 서비스에 분산해서 구현하면 코드 품질에 문제가 발생한다.
    1. 코드의 응집성이 떨어진다.
    2. 여러 응용 서비스에서 동일한 도메인 로직을 구현할 가능성이 높아진다.
- 소프트웨어의 가치를 높이려면 도메인 로직을 도메인 영역에 모아서 코드 중복이 발생하지 않도록 하고 응집도를 높여야 한다.

### 응용 서비스의 구현

- 응용 서비스는 표현 영역과 도메인 영역을 연결하는 매개체 역할을 하는데 이는 디자인 패턴에서 파사드(facade)와 같은 역할을 한다.

**응용 서비스의 크기**

1. 한 응용 서비스 클래스에 회원 도메인의 모든 기능 구현하기
2. 구분되는 기능별로 응용 서비스 클래스를 따로 구현하기

- 회원과 관련된 기능을 한 클래스에서 모두 구현할 경우 다음과 같은 모습을 갖는다.
- 한 도메인과 관련된 기능을 구현한 코드가 한 클래스에 위치하므로 각 기능에서 동일 로직에 대한 코드 중복을 제거할 수 있다는 장점이 있다. ex) 회원이 존재하지 않을 경우 Exception을 발생시키는 코드를 메서드로 구현하여 호출하는 방법

```java
public class MemberService {
    // 각 기능을 구현하는 데 필요한 리포지터리, 도메인 서비스 필드 추가
    private MemberRepository memberRepository;
    
    public void join(MemberJoinRequest joinRequest) { ... }
    public void changePassword(String memeberId, String currentPw, String newPw) { ... }
    public void initializePassword(String memeberId) { ... }
    public void leave(String memeberId, String currentPw) { ... }
}
```

- 코드 크기가 커진다는 것은 연관성이 적은 코드가 한 클래스에 함께 위치할 가능성이 높아짐을 의미하는데, 이는 결과적으로 관련 없는 코드가 뒤섞여서 코드를 이해하는 데 방해가 될 수 있다.
- 게다가 한 클래스에 코드가 모이기 시작하면 엄연히 분리하는 것이 좋은 상황임에도 습관적으로 기존에 존재하는 클래스에 억지로 끼워 넣게 된다. 이는 코드를 점점 얽히게 만들어 코드 품질을 낮추는 결과를 초래한다.
- 구분되는 기능별로 서비스 클래스를 구현하는 방식은 한 응용 서비스 클래스에서 한 개 내지 2~3개의 기능을 구현한다.
- 이 방식을 사용하면 클래스 개수는 많아지지만 한 클래스에 관련 기능을 모두 구현하는 것과 비교해서 코드 품질을 일정 수준으로 유지하는 데 도움이 된다.

```java
public class ChangePasswordService {
    private MemberRepository memberRepository;
    
    public void changePassword(String memberId, String curPw, String newPw) {
        Member member = memberRepository.findById(memberId);
        if (member == null) throw new NoMemberException(memberId);
        member.changePassword(curPw, newPw);
    }
}
```

**응용 서비스의 인터페이스와 클래스**

- 인터페이스를 만들고 이를 상속한 클래스를 만드는 것이 필요할까?
- 인터페이스가 필요한 상황: 구현 클래스가 여러 개인 경우
- 인터페이스가 명확하게 필요하기 전까지는 응용 서비스에 대한 인터페이스를 작성하는 것이 좋은 설계라고는 볼 수 없다.

**메서드 파라미터와 값 리턴**

- 응용 서비스가 제공하는 메서드는 도메인을 이용해서 사용자가 요구한 기능을 실행하는 데 필요한 값을 파라미터를 통해 전달받아야 한다.
- 필요한 각 값을 개별 파라미터로 전달받을 수도 있고, 값 전달을 위한 별도 데이터 클래스를 만들어 전달받을 수도 있다.
- 데이터 클래스를 파라미터로 전달받고 필요한 데이터를 추출해서 필요한 기능을 구현하면 된다.
- 응용 서비스는 표현 영역에서 필요한 데이터만 리턴하는 것이 기능 실행 로직의 응집도를 높이는 확실한 방법이다.

**표현 영역에 의존하기 않기**

- 응용 서비스의 파라미터 타입을 결정할 때 주의할 점은 표현 영역과 관련된 타입을 사용하면 안 된다는 점이다.
- ex) 표현 영역에 해당하는 HttpServletRequest나 HttpSession을 응용 서비스에 파라미터로 전달하면 안 된다.
- 응용 서비스에서 표현 영역에 대한 의존이 발생하면 응용 서비스만 단독으로 테스트하기가 어려워진다.
- 응용 서비스가 표현 영역의 역할까지 대신하는 상황이 발생할 경우 응집도가 깨지며 코드를 유지보수하는 비용을 증가시키는 원인이 된다.

**트랜잭션 처리**

- 프레임워크가 제공하는 트랜잭션 기능을 적극 사용하는 것이 좋다.
- 프레임워크가 제공하는 규칙을 따르면 간단한 설정만으로도 트랜잭션을 시작하고 커밋하고 익셉션이 발생하면 롤백할 수 있다.

**도메인 이벤트 처리**

- 도메인에서 발생한 상태 변경을 의미하며 ‘암호 변경’, ‘주문 취소’와 같은 것이 이벤트가 될 수 있다.
- 도메인 영역은 상태가 변경되면 이를 외부에 알리기 위해 이벤트를 발생시킬 수 있다.
- 도메인에서 이벤트를 발생시키면 그 이벤트를 받아서 처리할 코드가 필요한데, 그 역할을 하는 것이 바로 응용 서비스이다. 응용 서비스는 이벤트를 받아서 이벤트에 알맞은 후처리를 할 수 있다.

### 표현 영역

1. 사용자가 시스템을 사용할 수 있는(화면) 흐름을 제공하고 제어한다.
2. 사용자의 요청을 알맞은 응용 서비스에 전달하고 결과를 사용자에게 제공한다.
    1. ex) 암호 변경을 처리하는 표현 영역은 HTTP 요청 파라미터로부터 필요한 값을 읽어와 응용 서비스의 메서드가 요구하는 객체로 변환해서 요청을 전달한다. → **Controller단에서 응용 서비스를 실행하기 전에 체크하는 사항이라고 생각하면 되는 것일까?**
3. 사용자의 세션을 관리한다.

### 값 검증

- 표현 영역과 응용 서비스 두 곳에서 모두 수행할 수 있으나, 원칙적으로 모든 값에 대한 검증은 응용 서비스에서 처리한다.
- 응용 서비스에서 각 값이 존재하는지 형식이 올바른지 확인할 목적으로 익셉션을 사용할 때의 문제점은 사용자에게 좋지 않은 경험을 제공한다는 것이다. 이런 사용자 불편을 해소하려면 응용 서비스에서 값을 전달하기 전에 표현 영역에서 값을 검사하면 된다.
- 같은 값 검사를 표현 영역과 응용 서비스에서 중복해서 할 필요가 없다. 따라서, 응용 서비스를 사용하는 표현 영역 코드가 한 곳이면 구현의 편리함을 위해 다음과 같이 역할을 나누어 검증을 수행할 수도 있다.
    - 표현 영역: 필수 값, 값의 형식, 범위 등을 검증한다.
    - 응용 서비스: 데이터의 존재 유무와 같은 논리적 오류를 검증한다.
- 응용 서비스에서 어디까지 검증할지 여부는 엄격함이 어느 수준까지 필요하냐에 따라 달라질 수 있다.

### 권한 검사

- ‘사용자 U가 기능 F를 실행할 수 있는지’ 확인하는 것이 권한 검사이다.
- 개발할 시스템마다 권한의 복잡도가 달라진다. 단순한 시스템은 인증 여부만 검사하면 되는데 반해, 어떤 시스템은 관리자인지 여부에 따라 사용할 수 있는 기능이 달라지기도 한다.
- 실행할 수 있는 기능이 역할마다 달라지는 경우도 있다.
- 다음의 세 곳에서 권한 검사를 수행할 수 있다.
1. 표현 영역
    1. 인증된 사용자인지 아닌지 여부를 검사 ex) 회원 정보 변경 기능
        1. 컨트롤러에 웹 요청을 전달하기 전에 인증 여부를 검사해서 인증된 사용자의 웹 요청만 컨트롤러에 전달
        2. 인증된 사용자가 아닐 경우 로그인 화면으로 리다이렉트
2. 응용 서비스
    1. ex) 스프링 시큐리티는 AOP를 활용해서 애노테이션으로 서비스 메서드에 대한 권한 검사를 할 수 있는 기능을 제공한다.
3. 도메인
    1. 도메인 객체 수준의 권한 검사 로직은 도메인별로 다르므로 도메인에 맞게 보안 프레임워크를 확장하려면 프레임워크 자체에 대한 이해가 높아야 한다.

### 조회 전용 기능과 응용 서비스

- 서비스에서 수행하는 추가적인 로직이 없을뿐더러 조회 전용 기능이어서 트랜잭션이 필요하지도 않다.
- 이런 경우 표현 영역에서 바로 조회 전용 기능을 사용해도 된다.
- 응용 서비스가 사용자 요청 기능을 실행하는 데 별다른 기여를 하지 못한다면 굳이 서비스를 만들지 않아도 된다고 생각한다.
