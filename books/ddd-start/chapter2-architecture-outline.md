2장. 아키텍처 개요
===========

### 네 개의 영역

- 아키텍처를 설계할 때 출현하는 전형적인 영역이 ‘표현’, ‘응용’, ‘도메인’, ‘인프라스트럭처’의 네 영역이다.
- 표현 영역 또는 UI 영역은 사용자의 요청을 받아 응용 영역에 전달하고 응용 영역의 처리 결과를 다시 사용자에게 보여주는 역할을 한다. **스프링 MVC 프레임워크**가 표현 영역을 위한 기술에 해당한다.
- 표현 영역은 HTTP 요청을 응용 영역이 필요로 하는 형식으로 변환해서 응용 영역에 전달하고, 응용 영역의 응답을 HTTP 응답으로 변환해서 전송한다.
- **응용 서비스는 로직을 직접 수행하기보다는 도메일 모델에 로직 수행을 위임**한다.
- 도메인 영역은 도메인의 핵심 로직을 구현한다. **주문 도메인의 경우 ‘배송지 변경’, ‘결제 완료’, ‘주문 총액 계산’과 같은 핵심 로직을 도메인 모델에서 구현**한다.
- 인프라스트럭처 영역은 논리적인 개념을 표현하기보다는 실제 구현을 다룬다.

### 계층 구조 아키텍처

- 표현 → 응용 → 도메인 → 인프라스트럭처
- 표현 영역과 응용 영역은 도메인 영역을 사용하고, 도메인 영역은 인프라스트럭처 영역을 사용하므로 계층 구조를 적용하기에 적당해 보인다.
- 계층 구조 특성 상 상위 계층에서 하위 계층으로의 의존만 존재하고 그 반대는 의존하지 않는다.
- 인프라스트럭처에 의존하면 ‘테스트 어려움’과 ‘기능 확장의 어려움’ 이라는 두 가지 문제가 발생한다.

### DIP

- 고수준 모듈이 제대로 동작하려면 저수준 모듈을 사용해야 한다. 그런데 고수준 모듈이 저수준 모듈을 사용하면 앞서 계층 구조 아키텍처에서 언급했던 두 가지 문제(구현 변경과 테스트 어려움)가 발생한다.
- DIP는 이 문제를 해결하기 위해 저수준 모듈이 고수준 모듈에 의존하도록 바꾼다.
- 반대로 저수준 모듈이 고수준 모듈에 의존하려면 추상화한 **인터페이스** 활용
- 고수준 모듈은 더 이상 저수준 모듈에 의존하지 않고 구현을 추상화한 인터페이스에 의존한다. 실제 사용할 저수준 구현 객체는 다음 코드처럼 의존 주입을 이용해서 전달받을 수 있다.

```java
// 사용할 저수준 객체 생성
RuleDiscounter ruleDiscounter = new DroolsRuleDiscounter();

// 생성자 방식으로 주입
CalculateDiscountService calculateDiscountService = new CalculateDiscountService(ruleDiscounter);
```

- 구현 기술을 변경하더라도 CalculateDiscountService를 수정할 필요가 없다. 다음처럼 사용할 저수준 구현 객체를 생성하는 부분의 코드만 변경하면 된다.

```java
// 사용할 저수준 객체 변경
RuleDiscounter ruleDiscounter = new SimpleRuleDiscounter();

// 사용할 저수준 모듈을 변경해도 고수준 모듈을 수정할 필요가 없다
CalculateDiscountService calculateDiscountService = new CalculateDiscountService(ruleDiscounter);
```

### DIP 주의사항

- DIP의 핵심은 고수준 모듈이 저수준 모듈에 의존하지 않도록 하기 위함이다. DIP를 적용할 때 하위 기능을 추상화한 인터페이스는 고수준 모듈 관점에서 도출한다.

### DIP와 아키텍처

- 아키텍처에 DIP를 적용하면 인프라스트럭처 영역이 응용 영역과 도메인 영역에 의존(상속)하는 구조가 된다.

### 도메인 영역의 주요 구성요소

- 도메인 영역의 모델은 도메인의 주요 개념을 표현하며 핵심이 되는 로직을 구현한다.

| 요소 | 설명 |
| --- | --- |
| 엔티티           ENTITY | 고유의 식별자를 갖는 객체로 자신의 라이프사이클을 갖는다. 주문(Order), 회원(Member), 상품(Product)과 같은 도메인의 고유한 개념을 표현한다. 도메인 모델의 데이터를 포함하며 해당 데이터와 관련된 기능을 함께 제공한다. |
| 밸류               VALUE | 고유의 식별자를 갖지 않는 객체로 주로 개념적으로 하나인 도메인 객체의 속성을 표현할 때 사용된다. 배송지 주소를 표현하기 위한 주소(Address)나 구매 금액을 위한 금액(Money)과 같은 타입이 밸류 타입이다. 엔티티의 속성으로 사용될 뿐만 아니라 다른 밸류 타입의 속성으로도 사용될 수 있다. |
| 애그리거트 AGGREGATE | 애그리거트는 관련된 엔티티와 밸류 객체를 개념적으로 하나로 묶은 것이다. 예를 들어, 주문과 관련된 Order 엔티티, OrderLine 밸류, Order 밸류 객체를 ‘주문’ 애그리거트로 묶을 수 있다. |
| 도메인 서비스 DOMAIN SERVICE | 특정 엔티티에 속하지 않은 도메인 로직을 제공한다. ‘할인 금액 계산’은 상품, 쿠폰, 회원 등급, 구매 금액 등 다양한 조건을 이용해서 구현하게 되는데, 이렇게 도메인 로직이 여러 엔티티와 밸류를 필요로 할 경우 도메인 서비스에서 로직을 구현한다. |

### 엔티티와 밸류

- DB 테이블의 엔티티와 도메인 모델의 엔티티의 차이점은 도메인 모델의 엔티티는 데이터와 함께 도메인 기능을 함께 제공한다는 점이다.
- 도메인 모델의 엔티티는 단순히 데이터를 담고 있는 데이터 구조라기보다는 데이터와 함께 기능을 제공하는 객체이다. 도메인 관점에서 기능을 구현하고 기능 구현을 캡슐화해서 데이터가 임의로 변경되는 것을 막는다.
- 또 다른 차이점은 도메인 모델의 엔티티는 두 개 이상의 데이터가 개념적으로 하나인 경우 밸류 타입을 이용해서 표현할 수 있다는 것이다. RDBMS와 같은 관계형 데이터베이스는 밸류 타입을 제대로 표현하기 힘들다.

### 애그리거트

- 애그리거트는 관련 객체를 하나로 묶은 군집이다. 대표적인 예가 주문이다. 주문이라는 도메인 개념은 ‘주문’, ‘배송지 정보’, ‘주문자’, ‘주문 목록’, ‘총 결제 금액’의 하위 모델로 구성되는데 이 때 이 하위 개념을 표현한 모델을 하나로 묶어서 ‘주문’이라는 상위 개념으로 표현할 수 있다.
- 애그리거트를 사용하면 개별 객체가 아닌 관련 객체를 묶어서 객체 군집 단위로 모델을 바라볼 수 있게 된다. 개별 객체 관의 관계가 아닌 애그리거트 간의 관계로 도메인 모델을 이해하고 구현할 수 있게 되며, 이를 통해 큰 틀에서 도메인 모델을 관리할 수 있게 된다.
- 애그리거트는 군집에 속한 객체들을 관리하는 루트 엔티티를 갖는다. 루트 엔티티는 애그리거트에 속해 있는 엔티티와 밸류 객체를 이용해서 애그리거트가 구현해야 할 기능을 제공한다. 애그리거트를 사용하는 코드는 래그리거트 루트가 제공하는 기능을 실행하고 애그리거트 루트를 통해서 간접적으로 애그리거트 내의 다른 엔티티나 밸류 객체에 접근하게 된다.

### 리포지터리

- 리포지터리는 애그리거트 단위로 도메인 객체를 저장하고 조회하는 기능을 정의한다.
- 응용 서비스와 리포지터리는 밀접한 연관이 있다
    - 응용 서비스는 필요한 도메인 객체를 구하거나 저장할 때 리포지터리를 사용한다.
    - 응용 서비스는 트랜잭션을 관리하는데, 트랜잭션 처리는 리포지터리 구현 기술에 영향을 받는다.

### 인프라스트럭처 개요

- 인프라스트럭처는 표현 영역, 응용 영역, 도메인 영역을 지원한다. 도메인 객체의 영속성 처리, 트랜잭션, SMTP 클라이언트, REST 클라이언트 등 다른 영역에서 필요로 하는 프레임워크, 구현 기술, 보조 기능을 지원한다.

### 모듈 구성

![모듈구성.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/67ab6d1e-144a-4144-a377-7f889b2cb6dc/%E1%84%86%E1%85%A9%E1%84%83%E1%85%B2%E1%86%AF%E1%84%80%E1%85%AE%E1%84%89%E1%85%A5%E1%86%BC.png)

- 각 애그리거트와 모델과 리포지터리는 같은 패키지에 위치시킨다.
    - 예를 들어 주문과 관련된 Order, OrderLine, Orderer, OrderRepository 등은 com.myshop.order.domain 패키지에 위치시킨다.
- 도메인이 복잡하면 도메인 모델과 도메인 서비스를 다음과 같이 별도 패키지에 위치시킬 수도 있다
    - com.myshop.order.domain.order: 애그리거트 위치
    - com.myshop.order.domain.service: 도메인 서비스 위치
- 응용 서비스도 다음과 같이 도메인 별로 패키지를 구분할 수 있다.
    - com.myshop.catalog.application.product
    - com.myshop.catalog.application.category
