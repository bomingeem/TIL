8장. 애그리거트 트랜잭션 관리
===========

### 애그리거트와 트랜잭션

- 한 애그리거트를 두 사용자가 거의 동시에 변경할 때 트랜잭션이 필요하다.
    - 운영자가 배송지 정보를 조회하고 상태를 변경하는 동안 고객이 애그리거트를 수정하지 못하게 막는다.
    - 운영자가 배송지 정보를 조회한 이후에 고객에 정보를 변경하면 운영자가 애그리거트를 다시 조회한 뒤 수정하도록 한다.

### 선점 잠금

- 선점 잠금은 먼저 애그리거트를 구한 스레드가 애그리거트 사용이 끝날 때까지 다른 스레드가 해당 애그리거트를 수정하는 것을 막는 방식이다.

![선점잠금동작방식](https://user-images.githubusercontent.com/47099798/229339919-5b9fdb60-411d-406d-8da4-12b14e3b702c.png)

- 한 스레드가 애그리거트를 구하고 수정하는 동안 다른 스레드가 수정할 수 없으므로 동시에 애그리거트를 수정할 때 발생하는 데이터 충돌 문제를 해소할 수 있다.
- 선점 잠금은 보통 DBMS가 제공하는 행 단위 잠금을 사용해서 구현한다.
- 하이버네이트의 경우 PESSIMISTIC_WRITE를 잠금 모드로 사용하면 ‘for update’ 쿼리를 사용해서 선점 잠금을 구현한다.

### 선점 잠금과 교착 상태

- 선점 잠금 기능을 사용할 때는 잠금 순서에 따른 교착 상태(deadlock)가 발생하지 않도록 주의해야 한다.
1. 스레드1: A 애그리거트에 대한 선점 잠금 구함
2. 스레드2: B 애그리거트에 대한 선점 잠금 구함
3. 스레드1: B 애그리거트에 대한 선점 잠금 시도
4. 스레드2: A 애그리거트에 대한 선점 잠금 시도
- 두 스레드는 상대방 스레드가 먼저 선점한 잠금을 구할 수 없어 ‘교착 상태’에 빠지게 된다.
- 선점 잠금에 따른 교착 상태는 상대적으로 사용자 수가 많을 때 발생할 가능성이 높고, 사용자 수가 많아지면 교착 상태에 빠지는 스레드가 더 빠르게 증가하게 된다.
- 이런 문제가 발생하지 않도록 잠금을 구할 때 ‘최대 대기 시간을 지정’해야 한다.

### 비선점 잠금

- 비선점 잠금 방식은 잠금을 해서 동시에 접근하는 것을 막는 대신 변경한 데이터를 실제 DBMS에 반영하는 시점에 변경 가능 여부를 확인하는 방식이다.

![비선점잠금](https://user-images.githubusercontent.com/47099798/229339946-f7295a6d-1334-4a18-9f90-354a681dc8b2.png)

- 스레드 1과 스레드 2는 같은 버전을 갖는 애그리거트를 읽어와 수정하고 있다. 두 스레드 중 스레드1이 먼저 커밋을 시도한다. 이 시점에 애그리거트의 버전은 여전히 5이므로 애그리거트 수정에 성공하고 버전은 6이 된다. 스레드1이 트랜잭션을 커밋한 후에 스레드2가 커밋을 시도하는데, 이미 애그리거트 버전이 6이므로 스레드2는 데이터 수정에 실패하게 된다.

![비선점잠금2](https://user-images.githubusercontent.com/47099798/229339957-fbc73b99-6dfe-4985-852b-2fe3d5c571cc.png)

- 과정 2에서 운영자는 배송 상태 변경을 요청할 때 앞서 과정 1을 통해 받은 애그리거트의 버전 값을 함께 전송한다. 시스템은 애그리거트를 읽는데 해당 시점의 버전 값도 함께 읽어온다.
- 만약 과정 1에서 받은 버전 A와 과정 2.1을 통해 읽은 애그리거트의 버전 B가 다르면, 과정 1과 과정 2 사이에 다른 사용자가 해당 애그리거트를 수정한 겂이다.
- 만약 버전 A와 버전 B가 같다면 과정 1과 과정 2 사이에 그 누구도 애그리거트를 수정하지 않은 것이다. 이 경우 애그리거트를 수정하고 변경 내용을 DBMS에 반영한다.

### 강제 버전 증가

- 기능 실행 도중 루트가 아닌 다른 엔티티의 값이 변경된다면 이 경우 JPA는 루트 엔티티의 버전값을 증가하지 않는다.
- 연관된 엔티티의 값이 변경된다고 해도 루트 엔티티 자체의 값은 바뀌는 것이 없으므로 루트 엔티티의 버전 값을 갱신하지 않는 것이다.
- 애그리거트 내에 어떤 구성요소의 상태가 바뀌면 루트 애그리거트의 버전 값을 증가해야 비선점 잠금이 올바르게 동작한다.
- LockModeType.OPTIMISTIC_FORCE_INCREMENT을 사용하면 해당 엔티티의 상태가 변경되었는지 여부에 상관없이 트랜잭션 종료 시점에 버전 값 증가 처리를 한다.

### 오프라인 선점 잠금

- 오프라인 선점 잠금은 여러 트랜잭션에 걸쳐 동시 변경을 막는다. 첫 번째 트랜잭션을 시작할 때 오프라인 잠금을 선점하고, 마지막 트랜잭션에서 잠금을 해제한다. 잠금을 해제하기 전까지 다른 사용자는 잠금을 구할 수 없다.
- 잠금을 해제하지 않으면 다른 사용자는 영원히 잠금을 구할 수 없는 상황이 발생한다. 이런 사태를 방지하기 위해 오프라인 선점 방식은 ‘잠금의 유효 시간’을 가져야 한다.

### 오프라인 선점 잠금을 위한 LockManager 인터페이스와 관련 클래스

```java
public interface LockManager {
    LockId tryLock(String type, String id) throws LockException;
    void checkLock(LockId lockId) throws LockException;
    void releaseLock(LockId lockId) throws LockException;
    void extendLockExpiration(LockId lockId, long inc) throws LockException;
}
```

- 오프라인 선점 잠금은 크게  네 가지 기능을 제공한다.
1. 잠금 선점 시도
    1. tryLock()은 LockId를 리턴
    2. 잠금을 구하면 잠금을 해제하거나, 잠금이 유효한지 검사하거나, 잠금의 유효 시간을 늘릴 때 LockId를 사용한다.
2. 잠금 확인
    1. 잠금의 유효 시간이 지났으면 이미 다른 사용자가 잠금을 선점한다.
    2. 잠금을 선점하지 않은 사용자가 기능을 실행했다면 기능 실행을 막아야 한다.
3. 잠금 해제
4. 락 유효 시간 연장
