11장. CQRS
===========

### 단일 모델의 단점

- ID를 이용해서 애그리거트를 참조하는 방식을 사용하면 즉시 로딩 방식과 같은 JP의 쿼리 관련 최적화 기능을 사용할 수 없다.
- 직접 참조하는 방식으로 연결해도 고민거리가 생긴다. 조회 화면의 특성에 따라 같은 연관도 즉시 로딩이나 지연 로딩으로 처리해야 하기 때문이다.
- 경우에 따라 DBMS가 제공하는 전용 기능을 이용해서 조회 쿼리를 작성해야 해서 JPA의 네이티브 쿼리를 사용해야 할 수도 있다.
- 이런 구현 복잡도를 낮추는 간단한 방법이 있는 그것은 바로 **‘상태 변경을 위한 모델’**과 **‘조회를 위한 모델’**을 분리하는 것이다.

### CQRS

- 시스템이 제공하는 기능은 크게 두 가지로 나누어 생각해 볼 수 있다.
    - 상태를 변경하는 기능
    - 사용자 입장에서 상태 정보를 조회하는 기능
- 상태를 변경하는 범위와 상태를 조회하는 범위가 정확하게 일치하지 않기 때문에 단일 모델로 두 종류의 기능을 구현하면 모델이 불필요하게 복잡해진다.
- CQRS는 Command Query Responsibility Segregation의 약자로 상태를 변경하는 명령(Command)을 위한 모델과 상태를 제공하는 조회(Query)를 위한 모델을 분리하는 패턴이다.

![cqrs](https://user-images.githubusercontent.com/47099798/231050723-76bfddc5-80bb-40b7-b33f-3da6f79e7351.png)

- CQRS를 사용하면 각 모델에 맞는 구현 기술을 선택할 수 있다.
    - ex) 명령 모델은 객체 지향에 기반에서 도메일 모델을 구현하기에 적당한 JPA, 조회 모델은 DB 테이블에서 SQL로 데이터를 조회할 때 좋은 MyBatis → **조회 모델을 만든다는 것은 DTO와 어떤 차이일까?**
- 명령 모델과 조회 모델이 서로 다른 데이터 장소를 사용할 수도 있다.

![명령모델-조회모델](https://user-images.githubusercontent.com/47099798/231050770-7f38e41e-efe6-4404-8ab0-3dffa3577002.png)

- 명령 모델과 조회 모델이 서로 다른 데이터 저장소를 사용할 경우 데이터 동기화 시점에 따라 구현 방식이 달라질 수 있다.
- 명령 모델에서 데이터가 바뀌자마자 변경내역을 바로 조회 모델이 반영해야 한다면 동기 이벤트와 글로벌 트랜잭션을 사용해서 실시간으로 동기화 할 수 있지만 전반적인 성능이 떨어지는 단점이 있다.
- 서로 다른 저장소의 데이터를 특정 시간 안에만 동기화하면 된다면 비동기로 데이터를 전송해도 된다.

### 웹과 CQRS

- 조회 기능 요청 비율이 월등히 높은 서비스를 만드는 곳은 다양한 기법을 사용한다.
    - 쿼리 최적화를 통한 쿼리 실행 송도를 높임
    - 메모리에 조회 데이터를 캐시해서 응답 속도를 높임
    - 조회 전용 저장소 별도 사용
- 조회 속도를 높이기 위해 별도 처리를 하고 있다면 명시적으로 명령 모델과 조회 모델을 구분하자

### CQRS 장단점

- 장점
    - 명령 모델을 구현할 때 도메인 자체에 집중
    - 조회 성능을 향상시키는 데 유리함
- 단점
    - 구현해야 할 코드가 더 많음
    - 더 많은 구현 기술이 필요
- 이런 장단점을 고려해서 CQRS 패턴을 도입할지 여부를 결정해야 한다. 도메인이 복잡하지 않은데 CQRS를 도입하면 두 모델을 유지하는 비용만 높아지고 얻을 수 있는 이점은 없다. 반면 트래픽이 높은 서비스인데 단일 모델을 고집하면 유지보수 비용이 오히려 높아질 수 있으므로 CQRS 도입을 고려해야 한다.
