동적 계획법(Dynamic Programming, DP)
===========


### 동적 계획법이란?
동적 계획법(Dynamic Programming)은 큰 문제를 작은 문제로 나누어서 푸는 방식의 알고리즘이다.  
처음 주어진 문제를 더 작은 문제들로 나눈 뒤 각 조각의 답을 계산하고, 이 답들로부터 원래 문제에 대한 답을 계산해 낸다는 점에서 분할정복과 비슷하다.  
하지만 큰 차이점은 동적 계획법에서는 쪼개진 작은 문제가 중복이 되지만, 분할정복에서는 절대로 중복이 될 수 없다.  

다시 말하면, 동적 계획법과 분할정복의 차이는 문제를 나누는 방식이다.  
동적 계획법에서는 어떤 부분 문제는 두 개 이상의 문제를 푸는데 사용될 수 있기 때문에, 이 문제의 답을 여러 번 계산하는 대신 한번 계산하고 결과를 재활용함으로써 속도를 향상시킬 수 있다.  
이 때 이미 계산한 값을 저장해 두는 메모리를 캐시(cache)라 부르며, 두 번 이상 계산되는 부분 문제를 중복되는 부분 문제(overlapping subproblem)라고 부른다.  


### 동적 계획법의 등장
이미 했던 연산이 반복되는 결점을 보완하기 위해 동적 계획법이 고안되었다.    
원리는 처음 진행되는 연산은 기록해 두고, 이미 진행했던 연산이라면 다시 연산하는 것이 아니라 기록되어 있는 값을 가져온다.  

### 동적 계획법의 조건  
* 두 가지 속성을 만족해야 동적 계획법으로 풀 수 있다.  
  1. **Overlapping Subproblem** : 겹치는 부분(작은) 문제  
  2. **Optimal Substructure** : 최적 부분구조  
    
* Overlapping Subproblem  
  * 겹치는 부분 문제는 어떤 문제가 여러개의 부분문제로 쪼개질 수 있을 때 사용하는 용어이다.  
  * 이 때 **'부분 문제'** 란, 항상 새로운 부분 문제를 생성해내기 보다는 계속해서 같은 부분 문제가 여러번 재사용되거나 재귀 알고리즘을 통해 해결되는 문제를 가리킨다.  
* Optimal Substructure  
  * **최적 부분구조** 는 어떤 문제의 최적의 해결책이 그 부분 문제의 최적의 해결책으로부터 설계될 수 있는 경우를 말한다.  
  * 즉, 최적 부분구조일 때 **문제의 정답을 작은 문제의 정답에부터 구할 수 있다.**  
    

### 메모이제이션(Memoization)  
동적 계획법에서는 각 문제는 **한 번** 만 풀어야 한다.  
동일한 문제를 반복해야 할 경우, 한 번 계산된 결과를 저장해 두었다가 활용하는 방식으로 중복 계산을 줄이는 방법으로 코드의 구현에서는 배열에 저장하는 것으로 할 수 있다.  
아래와 같이 피보나치 수열로 메모이제이션 예시를 들었다  
```
int memo[100];
int fibo(int n) {
    if (n<=1) {
      return n;
    } else {
      if (memo[n] > 0) { //memo의 값이 존재한다면
        return memo[n]; //그 값을 그대로 사용
      }
      memo[n] = fibo(n-1) + fibo(n-2);
      return memo[n];
    }
}
```

### 동적 계획법 구현방식
1. TOP-DOWN  
큰 문제를 작은 문제로 쪼개면서 푸는 방법. **재귀** 로 구현  
아래와 같이 피보나치 수열로 예시로 들었다.  
```
int fiboArray[] = {0,};

int fibo(int n) {
    if (n<=2) return 1;
    if (fiboArray[n] == 0)
      fiboArray[n] = fibo(n-1) + fibo(n-2);
    return fiboArray[n];
}
```
fibo(6)을 호출하게 될 경우 fibo(6) 부터 작은 수를 호출하며 가장 작은 수까지 도달한다. 이 방식에서 메모이제이션이 사용되었다  


2. BOTTOM-UP  
작은 문제를 차례대로 푸는 방법. **반복문** 으로 구현  
```
int fibo(int n) {
    fiboArray[0] = 1;
    fiboArray[1] = 1;
    for (int i=2; i<=n; i++)
      fiboArray[i] = fiboArray[i-1] + fiboArray[i-2];
    return fiboArray[n];
}
```
fibo(6)을 호출하게 될 경우 for문 안에서 fiboArray[2]부터 fiboArray[6]까지 점진적으로 계산한다  
이렇듯 처음 값부터 최종 값까지 계산하는 방법이다  

### 동적 계획법을 통한 문제 풀이
* 먼저, 문제에서 구하려는 답을 문장으로 나타낸다  
* 이제 그 문장에 나와있는 변수의 개수만큼 메모하는 캐시 배열을 만든다  
* Top-down인 경우에는 재귀 호출의 인자의 개수가 된다  
* 마지막으로, 문제를 작은 문제로 나누고 수식(점화식)을 이용해서 문제를 표현해야 한다  


### DP의 장점과 단점
동적 계획법은 모든 방법을 일일히 검토하여 최적의 해를 찾아내는 방식의 알고리즘이다  
여기서 **그리디(탐욕) 알고리즘** 과 대비되는 것이 그리디 알고리즘의 경우 모든 해를 구하지 않고 순간마다 그 상황에서 최적의 해를 찾는 방식이다  
그리디 알고리즘은 닥치는 상황을 고려하여 해를 구하기 때문에 도출된 값이 항상 최적의 해라고 볼 수는 없다  
하지만 동적계획법은 모든 방법을 검토해 보고 결과적으로 효율적인 값을 택하기 때문에 그리디 알고리즘에 비해 시간이 오래 걸리지만 결과적으로는 항상 최적의 해를 구할 수 있다는 이점이 있다  
